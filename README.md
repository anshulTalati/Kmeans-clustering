# Kmeans-clustering

In this project, I have implemented one step of the Lloyd's algorithm for k-means clustering. The goal is to partition a set of points
into k clusters of neighboring points. It starts with an initial set of k centroids. Then, it repeatedly partitions the input according to which of these centroids is closest and then finds a new centroid for each partition. That is, if you have a set of points P and a set of k centroids C, the algorithm repeatedly applies the following steps:

* Project step:
* Partition the set P into k clusters of points Pi, one for each centroid Ci, such that a point p belongs to Pi if it is closest to the centroid Ci among all centroids.
* Update step: Calculate the new centroid Ci from the cluster Pi so that the x,y coordinates of Ci is the mean x,y of all points in Pi.
The datasets used are random points on a plane in the squares (i*2+1,j*2+1)-(i*2+2,j*2+2), with 0≤i≤9 and 0≤j≤9 (so k=100 in k-means). The initial centroids in centroid.txt are the points (i*2+1.2,j*2+1.2). So the new centroids should be in the middle of the squares at (i*2+1.5,j*2+1.5).
Project Description
In this project, you are asked to implement one step of the K-means clustering algorithm.

* You can compile KMeans.java using:

  * run kmeans.build

*You can run KMeans.java in standalone mode over a small dataset using:
  * sbatch kmeans.local.run

* The new centroids generated by program will be in the directory output and must be similar to solution-small.txt.

* Run it in distributed mode using:
  * sbatch kmeans.distr.run

* This will calculate kmeans on the large dataset points-large.txt and will write the result in the directory output-distr. Note that running in distributed mode will use up at least 10 of your SUs. So do this a couple of times only, after you make sure that your program works correctly in standalone mode.


## Pseudo-Code

To help you, I am giving you the pseudo code:

class Point {
    public double x;
    public double y;
}

Vector[Point] centroids;

mapper setup:
  read centroids from the distributed cache

map ( key, line ):
  Point p = new Point()
  read 2 double numbers from the line (x and y) and store them in p
  find the closest centroid c to p
  emit(c,p)

reduce ( c, points ):
  count = 0
  sx = sy = 0.0
  for p in points
      count++
      sx += p.x
      sy += p.y
  c.x = sx/count
  c.y = sy/count
  emit(c,null)
In Java main program args[0] is the data point file (points-small.txt or points-large.txt), args[1] is the centroids.txt, args[2] is the output directory. job.addCacheFile(new URI(args[1])) is used to broadcast the file centroids.txt to all mappers, and Mapper.Context.getCacheFiles to access the broadcast file at the mapper setup (method setup):
                * URI[] paths = context.getCacheFiles();
                ``Configuration conf = context.getConfiguration();
               `` FileSystem fs = FileSystem.get(conf); 
                ``BufferedReader reader = new BufferedReader(new InputStreamReader(fs.open(new Path(paths[0]))));

then use reader.readLine() to read the lines from the file and store the centroids to the vector centroids.
